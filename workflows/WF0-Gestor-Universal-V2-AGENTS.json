{
  "name": "WF 0: Gestor Universal V2 (Multi-Agent)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "gestor-ia",
        "options": {
          "allowedOrigins": "*"
        },
        "responseMode": "responseNode"
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "gestor-ia-universal"
    },
    {
      "parameters": {
        "jsCode": "// Extract & Validate Request - V2 with Agent Support\nconst client_id = $input.item.json.query?.client_id;\nconst agent_id = $input.item.json.query?.agent_id || 'default'; // NEW: Default to 'default' agent\nconst body = $input.item.json.body || {};\nconst headers = $input.item.json.headers || {};\n\n// ValidaÃ§Ãµes\nif (!client_id) {\n  throw new Error('client_id is required in query parameters');\n}\n\n// Extract message data based on channel\nlet messageData = {};\n\nif (body.conversation) {\n  // Chatwoot format\n  messageData = {\n    channel_type: 'chatwoot',\n    conversation_id: body.conversation.id?.toString(),\n    contact_id: body.sender?.phone_number || body.sender?.email,\n    user_message: body.content || '',\n    user_message_type: body.message_type || 'text',\n    user_attachments: body.attachments || [],\n    sender_name: body.sender?.name,\n    chatwoot_metadata: {\n      inbox_id: body.inbox?.id,\n      account_id: body.account?.id\n    }\n  };\n} else if (body.key) {\n  // Evolution API (WhatsApp) format\n  messageData = {\n    channel_type: 'whatsapp',\n    conversation_id: body.key.remoteJid,\n    contact_id: body.key.remoteJid,\n    user_message: body.message?.conversation || body.message?.extendedTextMessage?.text || '',\n    user_message_type: Object.keys(body.message || {})[0] || 'text',\n    user_attachments: [],\n    sender_name: body.pushName || '',\n    whatsapp_metadata: {\n      instance: body.instance,\n      message_id: body.key.id\n    }\n  };\n} else if (body.message) {\n  // Generic format\n  messageData = {\n    channel_type: body.channel || 'generic',\n    conversation_id: body.conversation_id || body.chat_id,\n    contact_id: body.contact_id || body.from,\n    user_message: body.message,\n    user_message_type: body.message_type || 'text',\n    user_attachments: body.attachments || [],\n    sender_name: body.sender_name || ''\n  };\n}\n\n// Validate HMAC signature (security)\nconst signature = headers['x-webhook-signature'];\nconst expectedSignature = headers['x-expected-signature'];\n\n// Return structured data\nreturn {\n  client_id,\n  agent_id, // NEW: Include agent_id\n  ...messageData,\n  timestamp: new Date().toISOString(),\n  headers,\n  raw_body: body\n};"
      },
      "id": "extract-validate",
      "name": "Extract & Validate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT check_and_increment_rate_limit(\n  '{{ $json.client_id }}',\n  500\n)::jsonb as result;",
        "options": {}
      },
      "id": "rate-limit-check",
      "name": "Rate Limit Check",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [650, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-main",
          "name": "Supabase Main DB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.result.allowed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "rate-limit-if",
      "name": "Rate Limit OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 429, \"error\": \"Rate limit exceeded\", \"reason\": $json.result.reason, \"retry_after\": 60 } }}",
        "options": {
          "responseCode": 429
        }
      },
      "id": "rate-limit-response",
      "name": "Rate Limit Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [850, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- UPDATED: Load from agents table with client info\nSELECT \n  a.client_id,\n  a.agent_id,\n  a.agent_name,\n  c.client_name,\n  a.system_prompt,\n  a.llm_model,\n  a.tools_enabled,\n  a.rag_namespace,\n  a.buffer_delay,\n  a.chatwoot_host,\n  a.chatwoot_token,\n  a.chatwoot_inbox_id,\n  a.evolution_instance_id,\n  a.whatsapp_provider,\n  a.whatsapp_config,\n  a.google_calendar_id,\n  a.google_sheet_id,\n  a.tool_credentials,\n  a.usage_limits,\n  a.tags,\n  a.custom_fields,\n  c.admin_email,\n  c.admin_phone\nFROM public.agents a\nJOIN public.clients c ON c.client_id = a.client_id\nWHERE a.client_id = '{{ $json.client_id }}'\n  AND a.agent_id = '{{ $json.agent_id }}'\n  AND a.is_active = true\n  AND c.is_active = true\nLIMIT 1;",
        "options": {}
      },
      "id": "load-agent-config",
      "name": "Load Agent Config",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1050, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-main",
          "name": "Supabase Main DB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.client_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "config-found-if",
      "name": "Agent Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 404, \"error\": \"Agent not found or inactive\", \"client_id\": $('Extract & Validate').item.json.client_id, \"agent_id\": $('Extract & Validate').item.json.agent_id } }}",
        "options": {
          "responseCode": 404
        }
      },
      "id": "agent-not-found-response",
      "name": "Agent Not Found Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1250, 500]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "=buffer:{{ $('Extract & Validate').item.json.client_id }}:{{ $('Extract & Validate').item.json.agent_id }}:{{ $('Extract & Validate').item.json.conversation_id }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "check-buffer",
      "name": "Check Buffer (Redis)",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1450, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Buffer Management Logic - UPDATED for multi-agent\nconst extractData = $('Extract & Validate').item.json;\nconst config = $('Load Agent Config').item.json;\nconst bufferExists = $input.item.json.value !== null;\n\nconst bufferKey = `buffer:${extractData.client_id}:${extractData.agent_id}:${extractData.conversation_id}`;\nconst bufferDelay = config.buffer_delay || 1;\n\nconst messageData = {\n  timestamp: new Date().toISOString(),\n  message: extractData.user_message,\n  type: extractData.user_message_type,\n  from: extractData.contact_id,\n  sender_name: extractData.sender_name\n};\n\nreturn {\n  buffer_key: bufferKey,\n  buffer_delay: bufferDelay,\n  buffer_exists: bufferExists,\n  message_data: messageData,\n  should_wait: bufferExists\n};"
      },
      "id": "buffer-logic",
      "name": "Buffer Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "operation": "lpush",
        "key": "={{ $json.buffer_key }}",
        "value": "={{ JSON.stringify($json.message_data) }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "push-to-buffer",
      "name": "Push to Buffer",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1850, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $('Buffer Logic').item.json.buffer_key }}",
        "value": "temp",
        "expire": true,
        "ttl": "={{ $('Buffer Logic').item.json.buffer_delay }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "set-buffer-ttl",
      "name": "Set Buffer TTL",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2050, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $('Buffer Logic').item.json.should_wait }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "should-process-if",
      "name": "Should Process Now?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 202, \"message\": \"Message buffered, waiting for more\", \"buffer_delay\": $('Buffer Logic').item.json.buffer_delay, \"agent_id\": $('Extract & Validate').item.json.agent_id } }}",
        "options": {
          "responseCode": 202
        }
      },
      "id": "buffered-response",
      "name": "Buffered Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2250, 500]
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": "={{ $('Buffer Logic').item.json.buffer_delay }}"
      },
      "id": "wait-buffer",
      "name": "Wait Buffer Delay",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [2450, 300]
    },
    {
      "parameters": {
        "operation": "lrange",
        "key": "={{ $('Buffer Logic').item.json.buffer_key }}",
        "start": 0,
        "end": -1,
        "options": {
          "dbNumber": 0
        }
      },
      "id": "retrieve-buffer",
      "name": "Retrieve Buffer Messages",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2650, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Buffer Logic').item.json.buffer_key }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "clear-buffer",
      "name": "Clear Buffer",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2850, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Combine buffered messages\nconst messages = $input.item.json.value || [];\n\nconst parsedMessages = messages.map(msg => {\n  try {\n    return typeof msg === 'string' ? JSON.parse(msg) : msg;\n  } catch (e) {\n    return { message: msg, timestamp: new Date().toISOString() };\n  }\n});\n\nparsedMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n\nconst combinedMessage = parsedMessages\n  .map(m => m.message)\n  .filter(m => m && m.trim())\n  .join('\\n');\n\nreturn {\n  combined_message: combinedMessage,\n  message_count: parsedMessages.length,\n  messages: parsedMessages\n};"
      },
      "id": "combine-messages",
      "name": "Combine Messages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "operation": "hgetall",
        "key": "=memory:{{ $('Extract & Validate').item.json.client_id }}:{{ $('Extract & Validate').item.json.agent_id }}:{{ $('Extract & Validate').item.json.conversation_id }}",
        "options": {
          "dbNumber": 1
        }
      },
      "id": "load-memory",
      "name": "Load Conversation Memory",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [3250, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "operation": "lrange",
        "key": "=history:{{ $('Extract & Validate').item.json.client_id }}:{{ $('Extract & Validate').item.json.agent_id }}:{{ $('Extract & Validate').item.json.conversation_id }}",
        "start": 0,
        "end": 19,
        "options": {
          "dbNumber": 1
        }
      },
      "id": "load-history",
      "name": "Load Conversation History",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [3250, 450],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build Context Window for LLM - UPDATED for agents\nconst config = $('Load Agent Config').item.json;\nconst combinedMsg = $('Combine Messages').item.json;\nconst memory = $('Load Conversation Memory').item.json.value || {};\nconst historyRaw = $('Load Conversation History').item.json.value || [];\n\nconst history = historyRaw.map(h => {\n  try {\n    return typeof h === 'string' ? JSON.parse(h) : h;\n  } catch (e) {\n    return null;\n  }\n}).filter(h => h !== null);\n\nconst messages = [\n  {\n    role: 'system',\n    content: config.system_prompt\n  }\n];\n\nif (memory.summary) {\n  messages.push({\n    role: 'system',\n    content: `Contexto da conversa anterior: ${memory.summary}`\n  });\n}\n\nhistory.forEach(h => {\n  messages.push({\n    role: h.role,\n    content: h.content\n  });\n});\n\nmessages.push({\n  role: 'user',\n  content: combinedMsg.combined_message\n});\n\nconst tools = [];\nconst toolsEnabled = config.tools_enabled || ['rag'];\n\nif (toolsEnabled.includes('rag')) {\n  tools.push({\n    type: 'function',\n    function: {\n      name: 'rag_search',\n      description: 'Busca informaÃ§Ãµes na base de conhecimento da empresa.',\n      parameters: {\n        type: 'object',\n        properties: {\n          query: {\n            type: 'string',\n            description: 'A consulta para buscar'\n          },\n          top_k: {\n            type: 'number',\n            description: 'NÃºmero de resultados',\n            default: 5\n          }\n        },\n        required: ['query']\n      }\n    }\n  });\n}\n\nif (toolsEnabled.includes('calendar_google')) {\n  tools.push({\n    type: 'function',\n    function: {\n      name: 'calendar_create',\n      description: 'Cria evento no Google Calendar',\n      parameters: {\n        type: 'object',\n        properties: {\n          summary: { type: 'string' },\n          start_datetime: { type: 'string' },\n          duration_minutes: { type: 'number' },\n          attendee_email: { type: 'string' },\n          description: { type: 'string' }\n        },\n        required: ['summary', 'start_datetime', 'duration_minutes']\n      }\n    }\n  });\n}\n\nreturn {\n  messages,\n  tools,\n  llm_model: config.llm_model,\n  rag_namespace: config.rag_namespace,\n  tool_credentials: config.tool_credentials,\n  memory_context: memory,\n  conversation_id: $('Extract & Validate').item.json.conversation_id,\n  client_id: $('Extract & Validate').item.json.client_id,\n  agent_id: $('Extract & Validate').item.json.agent_id\n};"
      },
      "id": "build-context",
      "name": "Build Context Window",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3450, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 200, \"message\": \"Processing started\", \"execution_id\": $workflow.id, \"agent_id\": $('Extract & Validate').item.json.agent_id } }}",
        "options": {}
      },
      "id": "ack-response",
      "name": "Acknowledge Processing",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3650, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "call-llm-marker",
              "name": "next_step",
              "value": "call_llm",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "marker-call-llm",
      "name": "â†’ Call LLM",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [3850, 300]
    },
    {
      "parameters": {
        "content": "## WF 0: Gestor Universal V2 (Multi-Agent)\n\n### âœ… MudanÃ§as implementadas:\n1. **agent_id** obrigatÃ³rio na URL\n2. Load Agent Config (agents + clients JOIN)\n3. Buffer isolado por agente\n4. Memory/History por agente\n5. RAG namespace especÃ­fico do agente\n\n### ðŸ“¡ Webhook URL Format:\n```\nPOST /gestor-ia?client_id=clinica_sorriso_001&agent_id=default\nPOST /gestor-ia?client_id=clinica_sorriso_001&agent_id=sdr\n```\n\n### ðŸ”„ Retrocompatibilidade:\n- Se agent_id nÃ£o for informado, usa 'default'\n- Clientes antigos continuam funcionando",
        "height": 450,
        "width": 400
      },
      "id": "sticky-note-1",
      "name": "Sticky Note - V2 Changes",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [240, 60]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [[{"node": "Extract & Validate", "type": "main", "index": 0}]]
    },
    "Extract & Validate": {
      "main": [[{"node": "Rate Limit Check", "type": "main", "index": 0}]]
    },
    "Rate Limit Check": {
      "main": [[{"node": "Rate Limit OK?", "type": "main", "index": 0}]]
    },
    "Rate Limit OK?": {
      "main": [
        [{"node": "Load Agent Config", "type": "main", "index": 0}],
        [{"node": "Rate Limit Error Response", "type": "main", "index": 0}]
      ]
    },
    "Load Agent Config": {
      "main": [[{"node": "Agent Found?", "type": "main", "index": 0}]]
    },
    "Agent Found?": {
      "main": [
        [{"node": "Check Buffer (Redis)", "type": "main", "index": 0}],
        [{"node": "Agent Not Found Response", "type": "main", "index": 0}]
      ]
    },
    "Check Buffer (Redis)": {
      "main": [[{"node": "Buffer Logic", "type": "main", "index": 0}]]
    },
    "Buffer Logic": {
      "main": [[{"node": "Push to Buffer", "type": "main", "index": 0}]]
    },
    "Push to Buffer": {
      "main": [[{"node": "Set Buffer TTL", "type": "main", "index": 0}]]
    },
    "Set Buffer TTL": {
      "main": [[{"node": "Should Process Now?", "type": "main", "index": 0}]]
    },
    "Should Process Now?": {
      "main": [
        [{"node": "Wait Buffer Delay", "type": "main", "index": 0}],
        [{"node": "Buffered Response", "type": "main", "index": 0}]
      ]
    },
    "Wait Buffer Delay": {
      "main": [[{"node": "Retrieve Buffer Messages", "type": "main", "index": 0}]]
    },
    "Retrieve Buffer Messages": {
      "main": [[{"node": "Clear Buffer", "type": "main", "index": 0}]]
    },
    "Clear Buffer": {
      "main": [[{"node": "Combine Messages", "type": "main", "index": 0}]]
    },
    "Combine Messages": {
      "main": [[
        {"node": "Load Conversation Memory", "type": "main", "index": 0},
        {"node": "Load Conversation History", "type": "main", "index": 0}
      ]]
    },
    "Load Conversation Memory": {
      "main": [[{"node": "Build Context Window", "type": "main", "index": 0}]]
    },
    "Load Conversation History": {
      "main": [[{"node": "Build Context Window", "type": "main", "index": 0}]]
    },
    "Build Context Window": {
      "main": [[{"node": "Acknowledge Processing", "type": "main", "index": 0}]]
    },
    "Acknowledge Processing": {
      "main": [[{"node": "â†’ Call LLM", "type": "main", "index": 0}]]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-11-06T12:00:00.000Z",
      "updatedAt": "2025-11-06T12:00:00.000Z",
      "id": "multi-agent",
      "name": "multi-agent"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-11-06T12:00:00.000Z",
  "versionId": "2"
}
