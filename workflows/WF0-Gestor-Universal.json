{
  "name": "WF 0: Gestor Universal",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "gestor-ia",
        "options": {
          "allowedOrigins": "*"
        },
        "responseMode": "responseNode"
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "gestor-ia-universal"
    },
    {
      "parameters": {
        "jsCode": "// Extract & Validate Request\nconst client_id = $input.item.json.query?.client_id;\nconst body = $input.item.json.body || {};\nconst headers = $input.item.json.headers || {};\n\n// Validações\nif (!client_id) {\n  throw new Error('client_id is required in query parameters');\n}\n\n// Extract message data based on channel\nlet messageData = {};\n\nif (body.conversation) {\n  // Chatwoot format\n  messageData = {\n    channel_type: 'chatwoot',\n    conversation_id: body.conversation.id?.toString(),\n    contact_id: body.sender?.phone_number || body.sender?.email,\n    user_message: body.content || '',\n    user_message_type: body.message_type || 'text',\n    user_attachments: body.attachments || [],\n    sender_name: body.sender?.name,\n    chatwoot_metadata: {\n      inbox_id: body.inbox?.id,\n      account_id: body.account?.id\n    }\n  };\n} else if (body.key) {\n  // Evolution API (WhatsApp) format\n  messageData = {\n    channel_type: 'whatsapp',\n    conversation_id: body.key.remoteJid,\n    contact_id: body.key.remoteJid,\n    user_message: body.message?.conversation || body.message?.extendedTextMessage?.text || '',\n    user_message_type: Object.keys(body.message || {})[0] || 'text',\n    user_attachments: [],\n    sender_name: body.pushName || '',\n    whatsapp_metadata: {\n      instance: body.instance,\n      message_id: body.key.id\n    }\n  };\n} else if (body.message) {\n  // Generic format\n  messageData = {\n    channel_type: body.channel || 'generic',\n    conversation_id: body.conversation_id || body.chat_id,\n    contact_id: body.contact_id || body.from,\n    user_message: body.message,\n    user_message_type: body.message_type || 'text',\n    user_attachments: body.attachments || [],\n    sender_name: body.sender_name || ''\n  };\n}\n\n// Validate HMAC signature (security)\nconst signature = headers['x-webhook-signature'];\nconst expectedSignature = headers['x-expected-signature']; // Will be set by client config\n\n// Return structured data\nreturn {\n  client_id,\n  ...messageData,\n  timestamp: new Date().toISOString(),\n  headers,\n  raw_body: body\n};"
      },
      "id": "extract-validate",
      "name": "Extract & Validate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT check_and_increment_rate_limit(\n  '{{ $json.client_id }}',\n  500\n)::jsonb as result;",
        "options": {}
      },
      "id": "rate-limit-check",
      "name": "Rate Limit Check",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [650, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-main",
          "name": "Supabase Main DB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.result.allowed }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "rate-limit-if",
      "name": "Rate Limit OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [850, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 429, \"error\": \"Rate limit exceeded\", \"reason\": $json.result.reason, \"retry_after\": 60 } }}",
        "options": {
          "responseCode": 429
        }
      },
      "id": "rate-limit-response",
      "name": "Rate Limit Error Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [850, 500]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  client_id, client_name, system_prompt,\n  llm_provider, llm_model, llm_config,\n  tools_enabled, rag_namespace, rag_config,\n  buffer_delay, timezone,\n  image_gen_provider, image_gen_model, image_gen_config,\n  google_credentials_vault_id,\n  chatwoot_token_vault_id,\n  evolution_token_vault_id\nFROM public.clients\nWHERE client_id = '{{ $json.client_id }}'\n  AND is_active = true\nLIMIT 1;",
        "options": {}
      },
      "id": "load-config",
      "name": "Load Client Config",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1050, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-main",
          "name": "Supabase Main DB"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $json.client_id }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "config-found-if",
      "name": "Config Found?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1250, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 404, \"error\": \"Client not found or inactive\" } }}",
        "options": {
          "responseCode": 404
        }
      },
      "id": "client-not-found-response",
      "name": "Client Not Found Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1250, 500]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "=buffer:{{ $('Extract & Validate').item.json.client_id }}:{{ $('Extract & Validate').item.json.conversation_id }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "check-buffer",
      "name": "Check Buffer (Redis)",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1450, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Buffer Management Logic\nconst extractData = $('Extract & Validate').item.json;\nconst config = $('Load Client Config').item.json;\nconst bufferExists = $input.item.json.value !== null;\n\nconst bufferKey = `buffer:${extractData.client_id}:${extractData.conversation_id}`;\nconst bufferDelay = config.buffer_delay || 1; // seconds\n\nconst messageData = {\n  timestamp: new Date().toISOString(),\n  message: extractData.user_message,\n  type: extractData.user_message_type,\n  from: extractData.contact_id,\n  sender_name: extractData.sender_name\n};\n\nreturn {\n  buffer_key: bufferKey,\n  buffer_delay: bufferDelay,\n  buffer_exists: bufferExists,\n  message_data: messageData,\n  should_wait: bufferExists // Se buffer existe, aguardar mais mensagens\n};"
      },
      "id": "buffer-logic",
      "name": "Buffer Logic",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "operation": "lpush",
        "key": "={{ $json.buffer_key }}",
        "value": "={{ JSON.stringify($json.message_data) }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "push-to-buffer",
      "name": "Push to Buffer",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1850, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{ $('Buffer Logic').item.json.buffer_key }}",
        "value": "temp",
        "expire": true,
        "ttl": "={{ $('Buffer Logic').item.json.buffer_delay }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "set-buffer-ttl",
      "name": "Set Buffer TTL",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2050, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "leftValue": "={{ $('Buffer Logic').item.json.should_wait }}",
              "rightValue": false,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "should-process-if",
      "name": "Should Process Now?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [2250, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 202, \"message\": \"Message buffered, waiting for more\", \"buffer_delay\": $('Buffer Logic').item.json.buffer_delay } }}",
        "options": {
          "responseCode": 202
        }
      },
      "id": "buffered-response",
      "name": "Buffered Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2250, 500]
    },
    {
      "parameters": {
        "unit": "seconds",
        "amount": "={{ $('Buffer Logic').item.json.buffer_delay }}"
      },
      "id": "wait-buffer",
      "name": "Wait Buffer Delay",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [2450, 300]
    },
    {
      "parameters": {
        "operation": "lrange",
        "key": "={{ $('Buffer Logic').item.json.buffer_key }}",
        "start": 0,
        "end": -1,
        "options": {
          "dbNumber": 0
        }
      },
      "id": "retrieve-buffer",
      "name": "Retrieve Buffer Messages",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2650, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "operation": "delete",
        "key": "={{ $('Buffer Logic').item.json.buffer_key }}",
        "options": {
          "dbNumber": 0
        }
      },
      "id": "clear-buffer",
      "name": "Clear Buffer",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [2850, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Combine buffered messages\nconst messages = $input.item.json.value || [];\n\n// Parse JSON strings\nconst parsedMessages = messages.map(msg => {\n  try {\n    return typeof msg === 'string' ? JSON.parse(msg) : msg;\n  } catch (e) {\n    return { message: msg, timestamp: new Date().toISOString() };\n  }\n});\n\n// Sort by timestamp\nparsedMessages.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n\n// Combine messages\nconst combinedMessage = parsedMessages\n  .map(m => m.message)\n  .filter(m => m && m.trim())\n  .join('\\n');\n\nreturn {\n  combined_message: combinedMessage,\n  message_count: parsedMessages.length,\n  messages: parsedMessages\n};"
      },
      "id": "combine-messages",
      "name": "Combine Messages",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3050, 300]
    },
    {
      "parameters": {
        "operation": "hgetall",
        "key": "=memory:{{ $('Extract & Validate').item.json.client_id }}:{{ $('Extract & Validate').item.json.conversation_id }}",
        "options": {
          "dbNumber": 1
        }
      },
      "id": "load-memory",
      "name": "Load Conversation Memory",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [3250, 300],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "operation": "lrange",
        "key": "=history:{{ $('Extract & Validate').item.json.client_id }}:{{ $('Extract & Validate').item.json.conversation_id }}",
        "start": 0,
        "end": 19,
        "options": {
          "dbNumber": 1
        }
      },
      "id": "load-history",
      "name": "Load Conversation History",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [3250, 450],
      "credentials": {
        "redis": {
          "id": "redis-main",
          "name": "Redis Main"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Build Context Window for LLM\nconst config = $('Load Client Config').item.json;\nconst combinedMsg = $('Combine Messages').item.json;\nconst memory = $('Load Conversation Memory').item.json.value || {};\nconst historyRaw = $('Load Conversation History').item.json.value || [];\n\n// Parse history\nconst history = historyRaw.map(h => {\n  try {\n    return typeof h === 'string' ? JSON.parse(h) : h;\n  } catch (e) {\n    return null;\n  }\n}).filter(h => h !== null);\n\n// Build messages array for LLM\nconst messages = [\n  {\n    role: 'system',\n    content: config.system_prompt\n  }\n];\n\n// Add memory summary if exists\nif (memory.summary) {\n  messages.push({\n    role: 'system',\n    content: `Contexto da conversa anterior: ${memory.summary}`\n  });\n}\n\n// Add conversation history\nhistory.forEach(h => {\n  messages.push({\n    role: h.role,\n    content: h.content\n  });\n});\n\n// Add current user message\nmessages.push({\n  role: 'user',\n  content: combinedMsg.combined_message\n});\n\n// Build tools array\nconst tools = [];\nconst toolsEnabled = config.tools_enabled || ['rag'];\n\nif (toolsEnabled.includes('rag')) {\n  tools.push({\n    type: 'function',\n    function: {\n      name: 'rag_search',\n      description: 'Busca informações na base de conhecimento da empresa. Use quando precisar de informações específicas sobre produtos, preços, políticas, etc.',\n      parameters: {\n        type: 'object',\n        properties: {\n          query: {\n            type: 'string',\n            description: 'A consulta para buscar na base de conhecimento'\n          },\n          top_k: {\n            type: 'number',\n            description: 'Número de resultados a retornar (padrão: 5)',\n            default: 5\n          }\n        },\n        required: ['query']\n      }\n    }\n  });\n}\n\nif (toolsEnabled.includes('calendar_google')) {\n  tools.push({\n    type: 'function',\n    function: {\n      name: 'calendar_create',\n      description: 'Cria um evento no Google Calendar',\n      parameters: {\n        type: 'object',\n        properties: {\n          summary: {\n            type: 'string',\n            description: 'Título do evento'\n          },\n          start_datetime: {\n            type: 'string',\n            description: 'Data e hora de início (ISO 8601 format)'\n          },\n          duration_minutes: {\n            type: 'number',\n            description: 'Duração em minutos'\n          },\n          attendee_email: {\n            type: 'string',\n            description: 'Email do participante'\n          },\n          description: {\n            type: 'string',\n            description: 'Descrição do evento'\n          }\n        },\n        required: ['summary', 'start_datetime', 'duration_minutes']\n      }\n    }\n  });\n}\n\nreturn {\n  messages,\n  tools,\n  llm_provider: config.llm_provider,\n  llm_model: config.llm_model,\n  llm_config: config.llm_config,\n  rag_namespace: config.rag_namespace,\n  memory_context: memory,\n  conversation_id: $('Extract & Validate').item.json.conversation_id,\n  client_id: $('Extract & Validate').item.json.client_id\n};"
      },
      "id": "build-context",
      "name": "Build Context Window",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3450, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"status\": 200, \"message\": \"Processing started\", \"execution_id\": $workflow.id } }}",
        "options": {}
      },
      "id": "ack-response",
      "name": "Acknowledge Processing",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3650, 300]
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "call-llm-marker",
              "name": "next_step",
              "value": "call_llm",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "marker-call-llm",
      "name": "→ Call LLM",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.3,
      "position": [3850, 300]
    },
    {
      "parameters": {
        "content": "## WF 0: Gestor Universal\n\n### Fluxo Implementado:\n1. ✅ Webhook Trigger\n2. ✅ Extract & Validate\n3. ✅ Rate Limit Check\n4. ✅ Load Client Config\n5. ✅ Buffer Management (Redis)\n6. ✅ Load Memory & History\n7. ✅ Build Context Window\n8. ⚠️ Call LLM (continua abaixo)\n\n### Próximos Nodes:\n- Call LLM (Google Vertex AI / OpenAI)\n- Execute Tools (RAG, Calendar, etc)\n- Save Memory & History\n- Log Execution\n- Update Usage\n- Send to Channel",
        "height": 400,
        "width": 350
      },
      "id": "sticky-note-1",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [240, 80]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Extract & Validate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract & Validate": {
      "main": [
        [
          {
            "node": "Rate Limit Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit Check": {
      "main": [
        [
          {
            "node": "Rate Limit OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rate Limit OK?": {
      "main": [
        [
          {
            "node": "Load Client Config",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Rate Limit Error Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Client Config": {
      "main": [
        [
          {
            "node": "Config Found?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Config Found?": {
      "main": [
        [
          {
            "node": "Check Buffer (Redis)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Client Not Found Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Buffer (Redis)": {
      "main": [
        [
          {
            "node": "Buffer Logic",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buffer Logic": {
      "main": [
        [
          {
            "node": "Push to Buffer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Push to Buffer": {
      "main": [
        [
          {
            "node": "Set Buffer TTL",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Buffer TTL": {
      "main": [
        [
          {
            "node": "Should Process Now?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Should Process Now?": {
      "main": [
        [
          {
            "node": "Wait Buffer Delay",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Buffered Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait Buffer Delay": {
      "main": [
        [
          {
            "node": "Retrieve Buffer Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Retrieve Buffer Messages": {
      "main": [
        [
          {
            "node": "Clear Buffer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clear Buffer": {
      "main": [
        [
          {
            "node": "Combine Messages",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine Messages": {
      "main": [
        [
          {
            "node": "Load Conversation Memory",
            "type": "main",
            "index": 0
          },
          {
            "node": "Load Conversation History",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Conversation Memory": {
      "main": [
        [
          {
            "node": "Build Context Window",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load Conversation History": {
      "main": [
        [
          {
            "node": "Build Context Window",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Context Window": {
      "main": [
        [
          {
            "node": "Acknowledge Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Acknowledge Processing": {
      "main": [
        [
          {
            "node": "→ Call LLM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [
    {
      "createdAt": "2025-11-06T00:00:00.000Z",
      "updatedAt": "2025-11-06T00:00:00.000Z",
      "id": "core",
      "name": "core"
    }
  ],
  "triggerCount": 1,
  "updatedAt": "2025-11-06T00:00:00.000Z",
  "versionId": "1"
}
